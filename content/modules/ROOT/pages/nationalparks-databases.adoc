= データベースへの接続
:navtitle: データベースへの接続

include::vars.adoc[]

このセクションでは、`nationalparks` アプリケーションが位置情報を保存するために使用するMongoDBデータベースをデプロイし、接続します。
最後に、`nationalparks` アプリケーションをマップ可視化ツールのバックエンドとしてマークし、OpenShiftのディスカバリ（discovery）メカニズムを使用して `parksmap` コンポーネントが動的に発見できるようにし、マップデータが自動的に表示されるようにします。

[.bordershadow]
image::roadshow-app-architecture-nationalparks-2.png[link="self",window=_blank]

[#storage]
== 背景: ストレージ

ほとんどの有用なアプリケーションは、何らかの形で「ステートフル」または「ダイナミック」であり、これは通常、データベースや他の形式のデータストレージによって実現されます。
このワークショップセクションでは、アプリケーションアーキテクチャにMongoDBを追加し、`nationalparks` デプロイメント（Deployment）がデータベースに接続するように設定します。
接続パラメータは、https://kubernetes.io/docs/concepts/configuration/secret/[Secret（シークレット）, window="_blank"] を使用して環境変数としてデプロイメントに提供されます。

[#create_mongodb_instance]
== 演習: MongoDBのデプロイ

最初のステップは、データベースの接続認証情報などの機密情報を保存するために使用される *Secret*（シークレット）を作成することです。
*Workloads*（ワークロード）→ *Secrets*（シークレット）で、右上の *Create*（作成）ボタンをクリックし、*From YAML*（YAMLから）を選択します。

[.bordershadow]
image::mongodb_create_secret.png[link="self",window=_blank]

エディタに、以下のYAMLを貼り付けます：

[source,role="copypaste",subs="attributes"]
----
apiVersion: v1
kind: Secret
metadata:
  name: mongodb-credentials
  namespace: {ocp4_starter_project}
type: Opaque
stringData:
  admin-usr: admin
  admin-pwd: secret
  app-usr: parksapp
  app-pwd: keepsafe
----

[.bordershadow]
image::mongodb_create_secret_dialog.png[link="self",window=_blank]

フォームの下部にある *Create*（作成）ボタンをクリックします。
Secretを作成したら、他のアプリケーションを追加したときと同様に、右上の *+* アイコンをクリックします。
*Container images*（コンテナイメージ）オプションを選択します。以下の詳細を入力します：

* Image section（イメージセクション）:
    - Image name from external registry（外部レジストリからのイメージ名）→ `mongo:6.0.4`
    - Runtime icon（ランタイムアイコン）→ `mongodb` を選択

* General section（一般セクション）:
    - Application（アプリケーション）→ `workshop`
    - Name（名前）→ `mongodb`

[.bordershadow]
image::mongodb_deploy_image_image.png[link="self",window=_blank]

* リソースタイプのドロップダウンが *Deployment*（デプロイメント）オプションに設定されていることを確認してください。
* *Show advanced Deployment options*（高度なデプロイメントオプションを表示）をクリックします。
    - ここで、以前に作成した `mongodb-credentials` という名前のSecretから供給される、次の2つの環境変数を追加します。
    - *+Add from ConfigMap or Secret*（ConfigMapまたはSecretから追加）をクリックし、名前に `MONGO_INITDB_ROOT_USERNAME` と入力します。
    - 値（value）には、リソースとして `mongodb-credentials` を、キー（key）として `admin-usr` を選択します。
    - 再度、*+Add from ConfigMap or Secret*（ConfigMapまたはSecretから追加）をクリックし、名前に `MONGO_INITDB_ROOT_PASSWORD` と入力します。
    - 値（value）には、リソースとして `mongodb-credentials` を、キー（key）として `admin-pwd` を選択します。
* Advanced options（高度なオプション）:
    - Create a route（ルートの作成）→ データベースはOpenShiftクラスター外のクライアントからアクセスされないため、*チェックを外します*。

[.bordershadow]
image::mongodb_deploy_image_general.png[link="self",window=_blank]

最後に、ページ下部の *Create*（作成）ボタンをクリックして、MongoDBコンテナをデプロイします。
次のステップは、nationalparksアプリケーションが接続を作成するために使用する、このMongoDBインスタンスに特定のユーザーを作成することです。
このために、Topology（トポロジー）ビューで *MongoDB Deployment*（MongoDBデプロイメント）をクリックし、右側のビューペインに表示される対応する *Pod* をクリックします。

[.bordershadow]
image::mongodb_deployment_topology_pod.png[link="self",window=_blank]

Podの詳細ビューが表示されるので、*Terminal*（ターミナル）をクリックして、基になるコンテナでターミナルセッションを開始します。

[.bordershadow]
image::mongodb_pod_details_terminal.png[link="self",window=_blank]

以下のスニペットをコピーしてターミナルウィンドウに貼り付け、適切な設定とロールを持つデータベースユーザーを作成します：

[source,role=copypaste]
----
mongosh -u admin -p secret --authenticationDatabase admin --eval 'use parksapp' --eval 'db.createUser({user: "parksapp", pwd: "keepsafe", roles: [{ role: "dbAdmin", db: "parksapp" },{ role: "readWrite", db: "parksapp" }]})' --quiet
----

NOTE: 本番環境では、コンテナのエントリポイントを変更するか、https://kubernetes.io/docs/concepts/workloads/pods/init-containers/[init container（initコンテナ）, window="_blank"] を使用してデータベース設定を管理できます。
コマンドが成功すると、以下の出力が表示されます：

[.console-output]
[source]
----
{ ok: 1 }
----

これで、データベースに関するすべてが準備できました。nationalparksアプリケーションに焦点を戻すことができます。
*Topology*（トポロジー）ビューに戻り、*nationalparks Deployment*（nationalparksデプロイメント）をクリックし、右側のビューペインのドロップダウンから _Actions → Edit Deployment_（アクション → デプロイメントの編集）を選択します。

[.bordershadow]
image::nationalparks_deployment_edit.png[link="self",window=_blank]

*Edit Deployment*（デプロイメントの編集）ダイアログで、*Environment Variables*（環境変数）セクションまでスクロールダウンし、次の4つのエントリを追加します。
まず、サーバーホストとデータベースを設定します：

    - `MONGODB_SERVER_HOST`: `mongodb`
    - `MONGODB_DATABASE`: `parksapp`

`MONGODB_SERVER_HOST` の値 `mongodb` は、MongoDBコンテナイメージをデプロイしたときに作成されたMongoDB *Service*（サービス）に解決されます。
他の2つは、`mongodb-credentials` Secretから供給される認証情報です。
*+Add from ConfigMap or Secret*（ConfigMapまたはSecretから追加）をクリックし、名前に `MONGODB_USER` と入力します。
値（value）には、リソースとして `mongodb-credentials` を、キー（key）として `app-usr` を選択します。
再度、*+Add from ConfigMap or Secret*（ConfigMapまたはSecretから追加）をクリックし、名前に `MONGODB_PASSWORD` と入力します。
値（value）には、リソースとして `mongodb-credentials` を、キー（key）として `app-pwd` を選択します。

[.bordershadow]
image::nationalparks_deployment_env_vars_secrets.png[link="self",window=_blank]

最後に、ダイアログの下部にある *Save*（保存）ボタンをクリックします。
これにより、アプリケーションの新しいバージョンがロールアウトされ、先ほどデプロイしたMongoDBインスタンスに接続されます。

[NOTE]
====
おそらく、データベース接続がどのようにして魔法のように機能し始めたのか疑問に思っているでしょう。
OpenShiftにアプリケーションをデプロイする場合、依存システムへの接続パラメータを定義するために、常にSecretsまたはConfigMapsを使用して環境変数を作成するのが最善です。
これにより、ソースコードを変更することなく、異なる環境間でのアプリケーションのポータビリティ（可搬性）が可能になります。
接続を実行し、データベーススキーマを作成するソースファイルは、
ここで表示できます：

[source,role="copypaste",subs="attributes"]
----
{ocp4_starter_openshift_roadshow}/nationalparks/blob/master/src/main/java/com/openshift/evg/roadshow/parks/db/MongoDBConnection.java#L44-l48
----

データベース接続が定義されていない場合に、アプリケーションが例外をキャッチ（catch）していることに注目してください。
これが、クラッシュすることなくデプロイできた理由です。
====

[#adding_labels]
== 演習: ラベルの追加

次に、MongoDBデプロイメントに割り当てられたラベルを修正しましょう。
*Topology*（トポロジー）ビューから、MongoDBデプロイメントを選択し、_Actions → Edit Labels_（アクション → ラベルの編集）を選択します。

[.bordershadow]
image::mongodb_deployment_labels.png[link="self",window=_blank]

以前と同様に、3つのラベルを追加します：

アプリケーション（Application）グループの名前：

[source,role=copypaste]
----
app=workshop
----

次に、このデプロイメントの名前：

[source,role=copypaste]
----
component=nationalparks
----

そして最後に、このコンポーネントがアプリケーション全体で果たす役割：

[source,role=copypaste]
----
role=database
----

[#exploring_openshift_magic]
== 演習: OpenShiftマジックの探求

`nationalparks` デプロイメントをデータベース接続の環境変数で更新した後、
いくつかの魔法が起こりました。
OpenShiftは、*ReplicaSet*（レプリカセット）を更新することにより、新しい変数を使用するアプリケーションの新しいバージョンをロールアウトしました。
これは `oc get rs -l app=nationalparks` の出力を見ることで確認できます：

[.console-output]
[source]
----
NAME                       DESIRED   CURRENT   READY   AGE
nationalparks-58bd4758fc   0         0         0       4m58s
nationalparks-7445576cd9   0         0         0       6m42s
nationalparks-789c6bc4f4   1         1         1       41s
----

現在および以前のReplicaSetのDESIRED（望ましい）インスタンス数とCURRENT（現在の）インスタンス数がわかります。
以前のインスタンスの望ましい数と現在の数は0です。
これは、OpenShiftが以前のアプリケーションPodを、新しい設定を使用する新しいPodに正常に置き換えたことを意味します。

[#data_data_everywhere]
== 演習: データ、データ、どこにでもデータ

データベースがデプロイされたので、再び `nationalparks` Webサービスにアクセスして
データをクエリできます：

[source,role="copypaste",subs="attributes"]
----
https://nationalparks-{ocp4_starter_project}.{ocp4_starter_apps_domain}/ws/data/all
----

その結果は？
[.console-output]
[source]
----
[]
----

データはどこでしょう？ 経験したプロセスを考えてみてください。アプリケーションをデプロイし、
次にデータベースをデプロイしました。
しかし、実際には何もデータをデータベースにロード（load）していません。

アプリケーションは、まさにそれを行うためのエンドポイントを提供します。
`nationalparks` アプリケーションにサンプルデータセットをMongoDBに挿入させるために、このURLをWebブラウザで開きます：

[source,role="copypaste",subs="attributes"]
----
https://nationalparks-{ocp4_starter_project}.{ocp4_starter_apps_domain}/ws/data/load
----

その結果は？
[.console-output]
[source]
----
Items inserted in database: 2893
----

その後 `/ws/data/all` に戻ると、今度はたくさんのJSONデータが表示されます。
NOTE: Firefox 54などのブラウザでは、結果のJSONを正しく解析できず、いくつかのエラーが報告されることがあります。
これはブラウザの問題であり、アプリケーションは正常に動作しています。

[source,role="copypaste",subs="attributes"]
----
https://parksmap-{ocp4_starter_project}.{ocp4_starter_apps_domain}
----

ただ一つ問題があります。
メインマップには*まだ*公園が表示されていません。
それは、フロントエンドが適切な*ラベル*（Label）を持つサービスとしか通信しようとしないからです。

[#working_with_labels]
== 演習: ラベルの操作

*Services*（サービス）や *Routes*（ルート）、*Selectors*（セレクター）を見たときに、*ラベル*が単なるキーと値のペアであることを学びました。
一般的に、*ラベル*は単なる任意のキー=値のペアです。例：

* `pizza=pepperoni`
* `pet=dog`
* `openshift=awesome`

parksmapの場合、アプリケーションは実際にOpenShift APIにクエリを投げ、
プロジェクト内の *Routes*（ルート）と *Services*（サービス）について尋ねています。
それらのいずれかが `type=parksmap-backend` という*ラベル*を持っていれば、アプリケーションは
マップデータをクエリするためにエンドポイントに接続することを知ります。
これを行うコードは
link:{ocp4_starter_openshift_roadshow}/parksmap-web/blob/master/src/main/java/com/openshift/evg/roadshow/rest/RouteWatcher.java#L20[RouteWatcher.javaファイルで確認できます,window='_blank']。

幸いなことに、コマンドラインはラベルを操作するための便利な方法を提供します。
`nationalparks` ルート（route）を `describe`（記述）してください：

[source,role=copypaste]
----
oc describe route nationalparks
----

[.console-output]
[source,subs="attributes"]
----
Name:                   nationalparks
Namespace:              {ocp4_starter_project}
Created:                2 hours ago
Labels:                 app=workshop
                        app.kubernetes.io/component=nationalparks
                        app.kubernetes.io/instance=nationalparks
                        app.kubernetes.io/name=java
                        app.kubernetes.io/part-of=workshop
                        app.openshift.io/runtime=java
                        app.openshift.io/runtime-version=11
                        component=nationalparks
                        role=backend  
Annotations:            openshift.io/host.generated=true                    
Requested Host:         nationalparks-{ocp4_starter_project}.{ocp4_starter_apps_domain}
                        exposed on router router 2 hours ago
Path:                   <none>
TLS Termination:        <none>
Insecure Policy:        <none>
Endpoint Port:          8080-tcp

Service:                nationalparks
Weight:                 100 (100%)
Endpoints:              10.1.9.8:8080
----

すでにいくつかのラベルが付いていることがわかります。
`oc label` を使用して、RouteWatcherがバックエンドを発見するために必要なラベルを追加します：

[source,role=copypaste]
----
oc label route nationalparks type=parksmap-backend
----

次のように表示されます：

[.console-output]
[source]
----
route.route.openshift.io/nationalparks labeled
----

parksmapのURLにアクセスして、ブラウザを確認してください：

[source,role="copypaste",subs="attributes"]
----
https://parksmap-{ocp4_starter_project}.{ocp4_starter_apps_domain}
----

[.bordershadow]
image::nationalparks-databases-new-parks.png[link="self",window=_blank]

公園が突然表示されるようになったことに気づくでしょう。
これは本当にクールですね！