= Nationalparks バックエンドアプリ
:navtitle: Nationalparks バックエンドアプリ

include::vars.adoc[]

このセクションでは、ビジュアライザーアプリケーション（前のワークショップセクションでデプロイした `parksmap` Webコンポーネント）に2つの主要なRESTエンドポイントを公開するバックエンドサービスをデプロイします。 このアプリケーションは、MongoDBデータベースに保存されている各国立公園の情報（座標を含む）をクエリします。 このアプリケーションは外部アクセスポイントも提供するため、エンドユーザーがAPIを直接使用できます。

[.bordershadow]
image::roadshow-app-architecture-nationalparks-1.png[link="self",window=_blank]

[#source_to_image]
== 背景: Source-to-Image (S2I)

前のワークショップセクションでは、既存のコンテナイメージをデプロイする方法を学びました。 ここでは、OpenShiftが既存のGitリポジトリにあるソースコードから直接コンテナイメージをビルドする方法を学びます。 これはSource-to-Imageプロジェクトを使用して実現されます。

link:{ocp4_starter_openshift_github}/source-to-image[Source-to-Image (S2I),window='_blank']は、Red Hatがスポンサーとなっているオープンソースプロジェクトで、以下の目標を掲げています：

[quote]
--
Source-to-image (S2I) は、再現可能なコンテナイメージをビルドするためのツールです。 S2Iは、ソースコードをコンテナイメージに挿入し、ビルダーイメージとビルドされたソースを組み込んだ新しいコンテナイメージをアセンブル（組み立て）することによって、すぐに実行可能なイメージを生成します。 その結果は、`docker run` ですぐに使用できます。 S2Iは、以前にダウンロードした依存関係やビルドされたアーティファクトなどを再利用するインクリメンタルビルドをサポートしています。
--

OpenShiftは、Dockerfile内の命令を使用したコンテナイメージのビルドや「カスタム」ビルドに加えて、S2Iをビルドメカニズムの1つとして使用できます。 OpenShiftは、ビルドPodと呼ばれる特別な *Pod* 内でS2Iプロセスを実行するため、ビルドはクォータ、リミット、リソーススケジューリング、およびOpenShiftのその他の側面に従います。 S2Iの完全な説明はこのワークショップの範囲を超えますが、
link:{ocp4_starter_openshift_docs}/html/images/creating-images[OpenShift S2Iドキュメント,window='_blank']
または link:{ocp4_starter_openshift_github}/source-to-image[GitHub,window='_blank'] で詳細情報を確認できます。 S2Iについて覚えておくべき唯一の重要な概念は、それが魔法だということです。

[#creating_a_application]
== 演習: バックエンドアプリケーションの作成

この演習の一部としてデプロイするバックエンドサービスは `nationalparks` と呼ばれます。 これは、MongoDBデータベースに対して2D地理空間クエリを実行し、世界中のすべての国立公園のマップ座標を特定して返すアプリケーションです。 もっと簡単に言えば、場所のJSONリストを返すWebサービスをデプロイするということです。

[#add_to_project]
=== プロジェクトへの追加
`nationalparks` コンポーネントは、既存のフロントエンド（parksmap）が消費するデータを提供するためのバックエンドであるため、これまで使用してきた既存のプロジェクト内でビルドおよびデプロイします。

[#using_application_code_on_git_server]
=== Gitサーバー上のアプリケーションコードの使用

OpenShiftは、アクセス可能な任意のGitリポジトリと連携できます。 これは、GitHub、GitLab、またはGitを話す他の任意のサーバーである可能性があります。 GitサーバーにWebhookを登録して、アプリケーションコードの更新によってトリガーされるOpenShiftビルドを開始することもできます！ ワークショップの後半では、コード変更を行い、アプリケーションをリビルドします。 では、バックエンドサービスのデプロイを見てみましょう。

[#deploying_the_backend_service]
=== バックエンドサービスのデプロイ

以前に既存のイメージで *+* ボタンを使用したのと同様に、ソースコードリポジトリを指定するために同じことができます。 シンプルな link:{ocp4_starter_openshift_roadshow}/nationalparks.git[Java,window='_blank'] S2Iイメージで試してみましょう。

Topology（トポロジー）ビューで、ヘッダーの *+* ボタンをクリックし、*Import from Git*（Gitからインポート）を選択します。

[.bordershadow]
image::nationalparks-show-add-options.png[link="self",window=_blank]

*Import from Git* ワークフローは、いくつかの選択に基づいてアプリをデプロイするプロセスをガイドします。 Git Repo URLに以下を入力します：

[source,role=copypaste,subs="attributes"]
----
{ocp4_starter_openshift_roadshow}/nationalparks.git
----

OpenShiftは、ソースコードで使用されているプログラミング言語を自動的に判別します。 *Import Strategy*（インポート戦略）を選択するオプションがあります。

*Edit Import Strategy*（インポート戦略の編集）をクリックします。

[.bordershadow]
image::nationalparks-import-strategy.png[width=500,link="self",window=_blank]

3つのオプションがあります：

* *Devfile*: link:{ocp4_starter_devfile_docs}[devfile,window='_blank'] 仕様を使用してアプリケーションスタックを作成します。 リポジトリにはdevfile形式の `devfile.yaml` という名前のファイルが含まれている必要があります。
* *Dockerfile*: ソースGitリポジトリ内の既存のDockerfileからコンテナイメージを作成します。
* *Builder Image*: Source-to-Imageと呼ばれるメカニズムを使用して、ソースコードから直接コンテナイメージを自動的に作成します - Dockerfileは不要です。

次のセクションで説明するように、ソースコードからコンテナイメージを作成するため、*Builder Image*（ビルダーイメージ）を選択します。

[.bordershadow]
image::nationalparks-import-strategy-build.png[link="self",window=_blank]

TIP: リポジトリにはマルチステージDockerfileが含まれているため、Dockerfileを使用することもできました。 この演習の目的は、OpenShiftのビルダーイメージ機能を体験することです。 ビルダーイメージとして *Java* が選択されていることを確認し、OpenJDK 11を使用するためにバージョン *openjdk-11-ubi8* を必ず選択してください。

*General*（一般）セクションまでスクロールダウンします。 以下を追加します：

*Application Name*（アプリケーション名）:
[source,role=copypaste]
----
workshop
----

*Name*（名前）:
[source,role=copypaste]
----
nationalparks
----

*Build*（ビルド）セクションで、*BuildConfig* を選択します。

*Deploy*（デプロイ）セクションで、*Deployment*（デプロイメント）を選択します。 *Advanced Options*（詳細オプション）で、*Create a route*（ルートの作成）が *チェックされている* ことを確認します。今回はこのビューから直接、別の *Secure Route*（セキュア ルート）を作成します。 *Show advanced Routing options*（高度なルーティングオプションを表示）をクリックします。すべてのデフォルトオプションをそのままにして、*Security*（セキュリティ）セクションに移動します。*Secure Route*（セキュア ルート）オプションをチェックします。 *TLS termination*（TLS終端）で、*Edge*（エッジ）を選択します。

[.bordershadow]
image::nationalparks-configure-service1.png[link="self",window=_blank]

[.bordershadow]
image::nationalparks-configure-service2.png[link="self",window=_blank]

下にスクロールして *Labels*（ラベル）セクションを展開し、3つのラベルを追加します。

[.bordershadow]
image::nationalparks-configure-service4.png[link="self",window=_blank]

[.bordershadow]
image::nationalparks-configure-service3.png[link="self",window=_blank]

Application（アプリケーション）グループの名前：

[source,role=copypaste]
----
app=workshop
----

次に、このデプロイメントの名前：

[source,role=copypaste]
----
component=nationalparks
----

そして最後に、このコンポーネントがアプリケーション全体で果たす役割：

[source,role=copypaste]
----
role=backend
----

*Create*（作成）をクリックして送信します。

[#monitoring-the-build]
=== ビルドのモニタリング

ビルドログを見るには、Topology（トポロジー）ビューで `nationalparks` エントリをクリックし、*Resources*（リソース）タブの *Builds*（ビルド）セクションにある *View Logs*（ログの表示）をクリックします。

[.bordershadow]
image::nationalparks-java-new-java-build.png[link="self",window=_blank]

アプリケーションの言語によって、ビルドプロセスは異なります。 しかし、依存関係がダウンロードされるため、最初のビルドには数分かかります。 これらすべてがリアルタイムで行われるのを見ることができます！ コマンドラインからも、*Builds*（ビルド）を見ることができます：

[.console-input]
[source,role="copypaste"]
----
oc get builds
----

以下のような出力が表示されます：

[.console-output]
[source]
----
NAME              TYPE      FROM          STATUS     STARTED              DURATION
nationalparks-1   Source    Git@b052ae6   Running    About a minute ago   1m2s
----

次のコマンドでビルドログを表示することもできます：

[.console-input]
[source,role="copypaste"]
----
oc logs -f builds/nationalparks-1
----

ビルドが
正常に完了すると：

* S2Iプロセスは、結果のイメージを内部のOpenShiftイメージレジストリにプッシュします
* *Deployment* (D) はイメージが変更されたことを検出し、
  これにより新しいデプロイメントが実行されます。
* この新しいデプロイメントのために *ReplicaSet* (RS) が生成されます。
* RSは実行中の *Pods* (Pod) がないことを検出し、デフォルトのレプリカ数が1であるため、1つのPodがデプロイされます。

最終的に、`oc get pods` コマンドを発行すると、ビルドPod
が完了（exited）し、アプリケーション *Pod* が準備完了（ready）かつ実行中（running）の状態であることがわかります：

[.console-output]
[source]
----
NAME                        READY     STATUS      RESTARTS   AGE
nationalparks-1-tkid3       1/1       Running     3          2m
nationalparks-1-build       0/1       Completed   0          3m
parksmap-57df75c46d-xltcs   1/1       Running     0          2h
----

OpenShift Webコンソールをもう一度見てください。 アプリケーション作成時に有効にしたため、*Route*（ルート）が作成されていることに気付くでしょう。 URLはWebコンソールで確認するか、コマンドラインで確認できます：

[.console-input]
[source,role="copypaste"]
----
oc get routes
----

以下のような出力が表示されるはずです：

[.console-output]
[source,role="copypaste",subs="attributes"]
----
NAME            HOST/PORT                                                   PATH      SERVICES        PORT        TERMINATION       WILDCARD
nationalparks   nationalparks-{ocp4_starter_project}.{ocp4_starter_apps_domain}      nationalparks   8080-tcp        edge 
parksmap        parksmap-{ocp4_starter_project}.{ocp4_starter_apps_domain}           parksmap        8080-tcp        edge        none
----

上記の例では、URLは次のとおりです：

[.console-output]
[source,subs="+attributes"]
----
https://nationalparks-{ocp4_starter_project}.{ocp4_starter_apps_domain}
----

これはバックエンドアプリケーションであるため、実際にはWebインターフェースはありません。 しかし、ブラウザで使用することはできます。parksmap
フロントエンドと連携するすべてのバックエンドは、`/ws/info/` エンドポイントを実装する必要があります。 テストするには、ブラウザでこのURLにアクセスしてください：

link:https://nationalparks-{ocp4_starter_project}.{ocp4_starter_apps_domain}/ws/info/[National Parks Info Page,window='_blank']

WARNING: Podが実行中（Running）でアプリケーションが利用できない場合は、まだヘルスチェックを設定していないため、数秒待ってからページを更新してください。 シンプルなJSON文字列が表示されます：

[source]
----
{"id":"nationalparks","displayName":"National Parks","center":{"latitude":"47.039304","longitude":"14.505178"},"zoom":4}
----

ワークショップの冒頭で、あなたは以下を読みました：

_これは、MongoDBデータベースに対して2D地理空間クエリを実行するアプリケーションです_

しかし、データベースはありません。 まだ。