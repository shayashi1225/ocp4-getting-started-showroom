= アプリのスケーリング
:navtitle: アプリのスケーリング

include::vars.adoc[]

[#deployments_and_replication_controllers]
== 背景: Deployments と ReplicaSets

*Service*（サービス）は、存在したりしなかったりする *Pod*（ポッド）へのルーティングとロードバランシングを提供しますが、*ReplicaSet*（RS、レプリカセット）と *ReplicationController*（RC、レプリケーションコントローラー）は、望ましい数の *Pod*（レプリカ）が実行されていることを指定し、保証するために使用されます。 例えば、アプリケーションサーバーを常に3つの *Pod*（インスタンス）で実行したい場合、*ReplicaSet* が必要です。 RSがないと、強制終了（kill）されたり終了したりした *Pod* は自動的に再起動されません。 *ReplicaSet* と *ReplicationController* は、OpenShiftで自己修復（self-healing）機能を提供します。*Deployment*（デプロイメント）は *ReplicaSet* を制御し、*ReplicationController* は *DeploymentConfig*（デプロイメント設定）によって制御されます。
link:{ocp4_starter_openshift_docs}/html/building_applications/deployments[デプロイメントのドキュメント,window='_blank']から：

[quote]
__
レプリケーションコントローラーと同様に、ReplicaSetはネイティブなKubernetes APIオブジェクトであり、指定された数のPodレプリカが常に実行されていることを保証します。 ReplicaSetとレプリケーションコントローラーの違いは、ReplicaSetがセットベースのセレクター要件をサポートするのに対し、レプリケーションコントローラーは等価ベースのセレクター要件のみをサポートする点です。
__

Kubernetesでは、*Deployment*（デプロイメント）が、何かがどのようにデプロイされるべきかを定義します。 ほとんどすべての場合において、*Pod*、*Service*、*ReplicaSet*、および *Deployment* リソースを一緒に使用します。 WebコンソールまたはCLIを使用してコンテナイメージをデプロイすると、OpenShiftがこれらすべてを作成します。 *Deployment* や *Service* なしで、いくつかの *Pod* と *ReplicaSet* が欲しいという高度なシナリオもいくつかあります。 これらのケースに興味がある場合は、ワークショップの後でインストラクターに尋ねてください。

[#exploring_deployment_related_objects]
== 演習: Deployment関連オブジェクトの調査

*ReplicaSet* と *Deployment* の背景知識がわかったので、それらがどのように連携するかを探ってみましょう。 `parksmap` イメージをデプロイするようOpenShiftに指示したときに作成された *Deployment* を見てみましょう：

[source,role="copypaste"]
----
oc get deployment
----

[.console-output]
[source]
----
NAME       READY   UP-TO-DATE   AVAILABLE   AGE
parksmap   1/1     1            1           20m
----

詳細については、*ReplicaSet* (RS) を調べてみましょう：

[source,role="copypaste"]
----
oc get rs
----

[.console-output]
[source]
----
NAME                  DESIRED   CURRENT   
 READY   AGE
parksmap-65c4f8b676   1         1         1       21m
----

この出力は、現在1つの *Pod* がデプロイされること（`Desired`）を期待しており、実際に1つの *Pod* がデプロイされている（`Current`）ことを示しています。 望ましい数を変更することで、OpenShiftにもっと多い、または少ない *Pod* が欲しいと伝えることができます。

TIP: OpenShiftの *HorizontalPodAutoscaler (HPA)* は、PodセットのCPUとメモリ使用量を監視し、RCを更新してインスタンスを追加することでアプリケーションの安定性を確保できます。
link:{ocp4_starter_openshift_docs}/html/nodes/working-with-pods#nodes-pods-autoscaling[ドキュメントでHorizontal Pod Autoscalerについて詳しく学ぶ,window='_blank']ことができます。

[#scaling_the_application]
== 演習: アプリケーションのスケーリング

この演習では、parksmapアプリケーションを2インスタンスにスケールアップします。 これは `oc scale` コマンドを使用するか、OpenShift WebコンソールでDesired Count（望ましい数）を増やすことで実行できます。 お好みの方法を選択してください。

[source,role="copypaste"]
----
oc scale --replicas=2 deployment/parksmap
----

または、*Developer Perspective*（開発者パースペクティブ）で2つのPodにスケールアップすることもできます。 Topology（トポロジー）ビューから、`parksmap` Deployment configをクリックし、*Details*（詳細）タブを選択します：

[.bordershadow]
image::parksmap-details.png[link="self",window=_blank]

次に、Podの視覚化の横にある *^* アイコンをクリックして、2つのPodにスケールアップします。

[.bordershadow]
image::parksmap-scaleup.png[link="self",window=_blank]

レプリカ数を変更したことを確認するには、次のコマンドを実行します：

[source,role="copypaste"]
----
oc get rs
----

[.console-output]
[source]
----
NAME                  DESIRED   CURRENT   READY   AGE
parksmap-65c4f8b676   2         2         2       23m
----

これで2つのレプリカがあることがわかります。 `oc get pods` コマンドでPodの数を確認します：

[source,role="copypaste"]
----
oc get pods
----

[.console-output]
[source]
----
NAME                        READY   STATUS    RESTARTS   AGE
parksmap-65c4f8b676-fxcrq   1/1     Running   0          92s
parksmap-65c4f8b676-k5gkk   1/1     Running   0          24m
----

最後に、*Service* が2つのエンドポイントを正確に反映していることを確認します：

[source,role="copypaste"]
----
oc describe svc parksmap
----

次のような出力が表示されます。 *Servce*（サービス）が2つの *Endpoint*（エンドポイント）をターゲットにしていることに注意してください：

[.console-output]
[source]
----
Name:              parksmap
Namespace:         user1
Labels:            app=workshop
                   app.kubernetes.io/component=parksmap
                   app.kubernetes.io/instance=parksmap
      app.kubernetes.io/part-of=workshop
                   component=parksmap
                   role=frontend
Annotations:       openshift.io/generated-by: OpenShiftWebConsole
Selector:          app=parksmap,deploymentconfig=parksmap
Type:              ClusterIP
IP:                172.30.22.209
Port:         
      8080-tcp  8080/TCP
TargetPort:        8080/TCP
Endpoints:         10.128.2.90:8080,10.131.0.40:8080
Session Affinity:  None
Events:            <none>
----

*Service* のエンドポイントを見る別の方法は、次のとおりです：

[source,role="copypaste"]
----
oc get endpoints parksmap
----

次の例のような出力が表示されます：

[.console-output]
[source]
----
NAME       ENDPOINTS                           AGE
parksmap   10.128.2.90:8080,10.131.0.40:8080   
 45m
----

各PodはOpenShift環境内で一意のIPを受け取るため、IPアドレスは異なる可能性があります。 エンドポイントリストは、サービスの後ろにいくつのPodがあるかをすばやく確認する方法です。 Developer Perspective（開発者パースペクティブ）でも両方の *Pod* が実行されていることがわかります：

[.bordershadow]
image::parksmap-scaled.png[link="self",window=_blank]

全体として、アプリケーションのスケーリングはこれほど簡単です。 OpenShiftは既存のイメージの新しいインスタンスを起動しているだけなので、アプリケーションのスケーリングは非常に迅速に行うことができます。特に、そのイメージが新しいPodが https://kubernetes.io/docs/concepts/scheduling-eviction/kube-scheduler/[スケジュールされた, window="_blank"]ノードにすでにキャッシュされている場合はなおさらです。

[#application_self_healing]
== アプリケーションの「自己修復」

OpenShiftの *RS* は、望ましい数の *Pod* が実行されているかを常に監視しているため、望ましいレプリカ数と現在の数が一致しない場合、OpenShiftが状況を「修正」することを期待するかもしれません。 現在2つの *Pod* が実行されているので、「誤って」1つを強制終了（kill）したらどうなるか見てみましょう。 `oc get pods` コマンドをもう一度実行し、*Pod* 名を1つ選びます。 そして、次を実行します：

[source,role="copypaste"]
----
oc delete pod parksmap-7dfd599cd7-vgc7z && oc get pods
----

[.console-output]
[source]
----
pod "parksmap-65c4f8b676-k5gkk" deleted
NAME                        READY   STATUS            RESTARTS     AGE
parksmap-65c4f8b676-bjz5g   1/1     ContainerCreating   0          9s
parksmap-65c4f8b676-fxcrq   1/1     Running             0  
         4m48s
----

何か気づきましたか？ 1つのコンテナが削除されましたが、新しいコンテナがすぐにその代わりに作成されています。 さらに、OpenShiftはアプリケーションインスタンスのliveness（生存）やreadiness（準備完了）をチェックするための基本的な機能を提供します。 基本的なチェックが不十分な場合、OpenShiftはコンテナ内でコマンドを実行してチェックを行うことも許可します。 そのコマンドは、インストールされている任意の言語を使用したスクリプトである可能性があります。 これらのヘルスチェックに基づき、OpenShiftが `parksmap` アプリケーションインスタンスが不健康であると判断した場合、そのインスタンスを削除し、代わりに新しいインスタンスを作成し、常に望ましいレプリカ数が維持されるようにします。 アプリケーションのプローブに関する詳細は、
ドキュメントの link:{ocp4_starter_openshift_docs}/html/building_applications/application-health[アプリケーションヘルス,window='_blank'] 
セクションおよびこのガイドの後半で入手できます。

[#scale_down]
== 演習: スケールダウン

続ける前に、アプリケーションを単一のインスタンスにスケールダウンしてください。
好きな方法で自由に行ってください。
WARNING: 1つのPodにスケールダウンしないと、後のセクションで予期しない動作が発生します。
これはOpenShiftに関連するものではなく、アプリケーションがそのようにコーディングされているためです。