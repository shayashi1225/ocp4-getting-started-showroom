= 継続的インテグレーションとパイプライン
:navtitle: 継続的インテグレーションとパイプライン

include::vars.adoc[]

このラボでは、パイプラインについて、また、アプリケーションのライフサイクルを
管理するようにOpenShiftでパイプラインを設定する方法について学びます。
継続的デリバリー（CD）パイプラインは、ソフトウェアを
バージョン管理からユーザーや顧客に届けるまでのプロセスを自動的に表現したものです。
ソフトウェアへのすべての変更（ソース管理にコミットされたもの）は、
リリースされるまでの複雑なプロセスを経ます。
このプロセスには、信頼性が高く再現可能な方法でソフトウェアをビルドすること、
およびビルドされたソフトウェア（「ビルド」と呼ばれる）を
テストとデプロイメントの複数のステージを通じて進行させることが含まれます。

OpenShift Pipelinesは、link:https://tekton.dev/[Tekton,window='_blank'] を使用してパイプラインを構築するための、
クラウドネイティブな継続的インテグレーションおよびデリバリー（CI/CD）ソリューションです。
Tektonは、柔軟でKubernetesネイティブなオープンソースCI/CDフレームワークであり、
基盤となる詳細を抽象化することで、複数のプラットフォーム（Kubernetes、サーバーレス、VMなど）にわたる
デプロイメントの自動化を可能にします。

[.bordershadow]
image::devops-pipeline-flow.png[link="self",window=_blank]

[#understanding_tekton]
== Tektonの理解

Tektonは、パイプラインの概念を標準化し、
CI/CDソリューション間で一貫した用語を提供するために、
ビルディングブロックとして多くの link:https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/[Kubernetesカスタムリソース,window='_blank'] を定義しています。
パイプラインを定義するために必要なカスタムリソースを以下に示します：

* `Task`: 特定のタスク（例：コンテナイメージのビルド）を実行する、再利用可能で疎結合なステップの集まり
* `Pipeline`: パイプラインの定義と、それが実行すべき `Task`
* `TaskRun`: Taskのインスタンスを実行した実行と結果
* `PipelineRun`: Pipelineのインスタンスを実行した実行と結果で、多くの `TaskRun` を含む

[.bordershadow]
image::tekton-architecture.png[link="self",window=_blank]

要するに、パイプラインを作成するには、次のことを行います：

* カスタムの `Task` を作成するか、link:https://github.com/tektoncd/catalog[既存の,window='_blank'] 再利用可能な `Task` をインストールする
* `Pipeline` と `PipelineResources` を作成して、アプリケーションのデリバリーパイプラインを定義する
* パイプライン実行のためのボリューム/ファイルシステムを提供するために
 `PersistentVolumeClaim` を作成するか、`PersistentVolumeClaim` を作成する `VolumeClaimTemplate` を提供する
* `PipelineRun` を作成して、パイプラインをインスタンス化して起動する

パイプラインの概念に関する詳細については、link:https://tekton.dev/docs[Tektonドキュメント,window='_blank'] を参照してください。
これは、パイプラインを定義するために利用可能なさまざまなパラメータや属性を理解するための優れたガイドを提供します。

[#create_your_pipeline]
== 演習: パイプラインの作成

パイプラインはアプリケーションをデリバリーサイクルの異なるステージ間で昇格させる機能を提供するため、
パイプラインを実行するCIサーバーであるTektonは、
CIの役割を持つプロジェクトにデプロイされます。
このプロジェクトで実行されるパイプラインは、
デリバリーサイクルの異なるステージをモデル化するすべてのプロジェクトと
対話する権限を持ちます。

それでは、Nationalparksバックエンド用のTektonパイプラインを作成しましょう。
Developer Perspective（開発者パースペクティブ）で、左側のナビゲーションの *Pipelines -> Pipelines*（パイプライン -> パイプライン）をクリックし、*Create -> Pipeline*（作成 -> パイプライン）をクリックします。

[.bordershadow]
image::devops_create_pipeline.png[link="self",window=_blank]

ここで、インタラクティブなパイプラインビルダーを見ることができます。*Add task*（タスクの追加）ボタンをクリックしてパイプラインにタスクを追加できます。
作成されたタスクをクリックしてパイプラインにパラメータを追加することもできます。
ここでは時間を節約するために、*YAML view*（YAMLビュー）を使用してパイプラインを作成します。

[.bordershadow]
image::devops_pipeline_builder_yaml.png[link="self",window=_blank]

さて、使用している言語に応じて、適切なパイプラインを作成する必要があります：

====
*Java*

ここで、このTektonパイプラインをYAMLテキストエリアにコピーできます。
このパイプラインは、ローカルのGitサーバー（Gitea）からソースコードをクローンし、
アプリケーションをビルド・テストし、コンテナイメージをビルドしてOpenShiftにデプロイします。

[source,role="copypaste",subs="attributes"]
----
apiVersion: tekton.dev/v1
kind: Pipeline
metadata:
  name: nationalparks-pipeline
spec:
  params:
    - default: nationalparks
      name: APP_NAME
      type: string
    - default: {ocp4_starter_gitea_url}/{ocp4_starter_gitea_user}/nationalparks.git
      description: The application git repository url
      name: APP_GIT_URL
      type: string
    - default: master
      description: The application git repository revision
      name: APP_GIT_REVISION
      type: string
  tasks:
    - name: git-clone
    params:
        - name: URL
          value: $(params.APP_GIT_URL)
        - name: REVISION
          value: $(params.APP_GIT_REVISION)
        - name: SUBMODULES
          value: 'true'
        - name: DEPTH
          value: '1'
        - name: SSL_VERIFY
        value: 'true'
        - name: DELETE_EXISTING
          value: 'true'
        - name: VERBOSE
          value: 'true'
      taskRef:
        kind: Task
        name: git-clone
      workspaces:
        - name: output
          workspace: app-source
    - name: build-and-test
      params:
        - name: MAVEN_IMAGE
          value: maven:3.8.3-openjdk-11
        - name: GOALS
          value:
            - package
        - name: PROXY_PROTOCOL
          value: http
      runAfter:
   - git-clone
      taskRef:
        kind: Task
        name: maven
      workspaces:
        - name: source
          workspace: app-source
        - name: maven_settings
          workspace: maven-settings
    - name: build-image
      params:
        - name: IMAGE
        value: image-registry.openshift-image-registry.svc:5000/$(context.pipelineRun.namespace)/$(params.APP_NAME):latest
        - name: BUILDER_IMAGE
          value: registry.redhat.io/rhel8/buildah:latest
        - name: STORAGE_DRIVER
          value: vfs
        - name: DOCKERFILE
          value: ./Dockerfile
        - name: CONTEXT
          value: .
 - name: TLSVERIFY
          value: 'true'
        - name: FORMAT
          value: oci
      runAfter:
        - build-and-test
      taskRef:
        kind: Task
        name: buildah
      workspaces:
        - name: source
          workspace: 
 app-source
    - name: redeploy
      params:
        - name: SCRIPT
          value: oc rollout restart deployment/$(params.APP_NAME)
      runAfter:
        - build-image
      taskRef:
        kind: Task
        name: openshift-client
  workspaces:
    - name: app-source
    - name: maven-settings
----

さて、*Pipeline builder*（パイプラインビルダー）ビューに戻って
視覚的に確認しましょう。

image::devops_pipeline_builder_java.png[link="self",window=_blank]

このパイプラインには4つのTaskが定義されています：

- *git clone*: これは、nationalparksのソースリポジトリをクローンし、
  `app-source` という `Workspace`（ワークスペース）に保存する `Task` です。
  これは、そのために作成されたPVC `app-source-workspace` を使用します
- *build-and-test*: `maven` `Task` を使用してJavaアプリケーションをビルド・テストします
- *build-image*: これは link:https://buildah.io/[buildah,window='_blank'] Taskで、
  OpenShift内でバイナリファイル（この場合は前のタスクで生成されたJARアーティファクト）を入力として
  イメージをビルドします
- *redeploy*: `openshift-client` Taskを使用して、
  前のラボで作成した `nationalparks` という名前のDeployment（デプロイメント）を使用して、
  作成されたイメージをOpenShiftにデプロイします。

image::devops_pipeline_tasks_java.png[link="self",window=_blank]

パイプラインはパラメトリックで、デフォルト値が
すでに事前設定されています。
2つの *Workspaces*（ワークスペース）を使用しています：

- *app-source*: 次に作成する *PersistentVolumeClaim*（永続ボリューム要求） `app-source-pvc` に
  リンクされています。 これは、異なる *Task* で使用される
  アーティファクトを保存するために使用されます
- *maven_settings*: Mavenキャッシュ用の *EmptyDir* ボリュームです。
  これは、後続のMavenビルドを高速化するためにPVCで拡張することもできます

image::devops_pipeline_workspaces_java.png[link="self",window=_blank]

// *.NET*

// ここで、このTektonパイプラインをYAMLテキストエリアにコピーできます。
このパイプラインは、GitHubからソースコードをクローンし、
アプリケーションをビルド・テストし、コンテナイメージをビルドしてOpenShiftにデプロイします。
// [.console-input]
// [source,bash,subs="+attributes,macros+"]
// ----
// apiVersion: tekton.dev/v1beta1
// kind: Pipeline
// ... (.NET YAML content)
// ----

// さて、*Pipeline builder*（パイプラインビルダー）ビューに戻って視覚的に確認しましょう。
// image::devops_pipeline_builder_dotnet.png[Pipeline Builder Java]

// このパイプラインには3つのTaskが定義されています：
// ... ( .NET Task descriptions)
// image::devops_pipeline_tasks_dotnet.png[Pipeline Tasks Java]

// パイプラインはパラメトリックで、デフォルト値がすでに事前設定されています。
// 1つの *Workspace*（ワークスペース）を使用しています：
// ... ( .NET Workspace description)
// image::devops_pipeline_workspaces_dotnet.png[Pipeline Workspaces Java]

// *Javascript*

// ここで、このTektonパイプラインをYAMLテキストエリアにコピーできます。
このパイプラインは、GitHubからソースコードをクローンし、
アプリケーションをビルド・テストし、コンテナイメージをビルドしてOpenShiftにデプロイします。
// [.console-input]
// [source,bash,subs="+attributes,macros+"]
// ----
// apiVersion: tekton.dev/v1beta1
// kind: Pipeline
// ... (JS YAML content)
// ----

`Pipeline` は、CDパイプラインのユーザー定義モデルです。
パイプラインのコードは、ビルドプロセス全体を定義します。
これには通常、アプリケーションのビルド、テスト、
デリバリーのステージが含まれます。
// Tektonの `Task` は、1つ以上のシーケンシャルなステップのコレクションであり、
// 各ステップは独自のコンテナで実行されます。
// 各ステップは通常、コードのコンパイル、テストの実行、
// またはコンテナイメージのビルドなど、単一の操作を実行します。
// Taskは再利用性が高く、さまざまなユースケースをサポートするために
// パラメータ化できます。
// さて、*Pipeline builder*（パイプラインビルダー）ビューに戻って視覚的に確認しましょう。
// image::devops_pipeline