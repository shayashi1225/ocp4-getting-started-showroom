= Parksmap アプリ
:navtitle: Parksmap アプリ
include::vars.adoc[]
:experimental:

このセクションでは、`parksmap` とも呼ばれるParksMapアプリケーションのWebコンポーネントをデプロイします。 このコンポーネントは、OpenShiftのサービスディスカバリ（service discovery）メカニズムを使用してバックエンドサービスを発見し、そのデータをマップに表示します。

[.bordershadow]
image::roadshow-app-architecture-parksmap-1.png[link="self",window=_blank]

[#deploy_your_first_image]
== 演習: 最初のコンテナイメージのデプロイ

まず、最も簡単なことから始めましょう - 古き良き
DockerフォーマットのイメージをOpenShiftで実行させます。 これは信じられないほど簡単です。
OpenShiftでは、Webコンソールから直接行うことができます。
*{ocp4_starter_project}* プロジェクトの {ocp4_starter_console_url}/topology/ns/{ocp4_starter_project}[topology（トポロジー）ビュー, link="self",window=_blank] に戻ります。

左上にある *+* アイコンをクリックします。 OpenShiftにアプリケーションをデプロイするための複数のオプションがあるメニューが表示されます。 *Container images*（コンテナイメージ）をクリックして、デプロイしたいイメージの情報を指定できるダイアログを開きます。

[.bordershadow]
image::openshift-console-add-container.png[link="self",window=_blank]

*Image Name*（イメージ名）フィールドに、以下をコピー/ペーストします：

[source,role="copypaste",subs="attributes"]
----
{ocp4_starter_parksmap_image}
----

OpenShiftは指定されたコンテナレジストリにアクセスし、イメージの詳細を取得します。
画面は次のようになります：

[.bordershadow]
image::parksmap-image.png[link="self",window=_blank]

*Runtime Icon*（ランタイムアイコン）で、OpenShiftトポロジービュー用のアイコンを選択します。 このフロントエンドはSpring Bootで作成されているため、*spring-boot* を選択します。
以下の値が設定されていることを確認してください：

*Application Name*（アプリケーション名）:
[source,role=copypaste]
----
workshop
----

*Name*（名前）:
[source,role=copypaste]
----
parksmap
----

NOTE: *Application Name*（アプリケーション名）はアプリケーション全体の名前であり、*Name*（名前）フィールドは個々のコンポーネントに付けられた名前を表します。 この場合、`parksmap` コンポーネントがデプロイするコンテナです。

*Resource type*（リソースタイプ）セクションから *Deployment*（デプロイメント）が選択されていることを確認します。
NOTE: *Resource type*（リソースタイプ）については、後の章で詳しく説明します。
*"Advanced options"*（詳細オプション）の下にある *Create a route*（ルートの作成）の横のチェックボックスを *オフ* にします。
学習のため、アプリケーションの *Route*（ルート）は後で作成します。
ページの下部にある Advanced Options（詳細オプション）セクションの *Labels*（ラベル）をクリックし、後でこのデプロイメントを識別するために使用できるラベルを追加します。 ラベルは、Webコンソールやコマンドラインでコンポーネントを識別し、フィルタリングするのに役立ちます。

3つのラベルを追加します。 各ラベルの名前=値のペアを入力した後、次を入力する前に kbd:[Return]（またはキーボードによっては kbd:[Enter]）を押します。 最初のラベルはアプリケーションの名前です。

[source,role=copypaste]
----
app=workshop
----

次に、このデプロイメントの名前。
[source,role=copypaste]
----
component=parksmap
----

そして最後に、このコンポーネントがアプリケーション全体で果たす役割。

[source,role=copypaste]
----
role=frontend
----

[.bordershadow]
image::parksmap-image-options.png[width=600,link="self",window=_blank]

[.bordershadow]
image::parksmap-advanced-image-options.png[width=600,link="self",window=_blank]

次に、青い *Create*（作成）ボタンをクリックします。
*Topology*（トポロジー）ページにリダイレクトされ、`workshop` アプリケーション内の `parksmap` デプロイメント設定の視覚化が表示されるはずです。

[.bordershadow]
image::parksmap-dc-topology.png[width=400,link="self",window=_blank]

これらが、OpenShiftでコンテナイメージをデプロイするために必要なすべてのステップです。
これは、EXPOSEポートを定義する、*rootユーザー*や他のユーザー名として実行する必要がない、単一の終了しないCMD（起動時に実行）など、ベストプラクティスに従う任意のコンテナイメージで機能します。
これらは、アプリケーションの https://github.com/openshift-roadshow/parksmap-web/blob/master/Dockerfile[Dockerfile, window="_blank"] で確認できます。

NOTE: アプリケーションを大規模にデプロイする場合、適切なラベルを提供することが重要です。
OpenShiftは、概要（Overview）ページでコンポーネントを定義しグループ化するために *app* というラベルを使用します。
明示的に指定しない場合、OpenShiftはデフォルト値でこのラベルを作成します。

[#containers_and_pods]
== 背景: コンテナとPod

先に進む前に、コンテナと *Pod*（ポッド）がどのように関連しているかを理解することが重要です。
このワークショップでは、これらの技術に関する背景は説明しませんが、質問があればインストラクターにお知らせください。
代わりに、すぐに飛び込んで使い始めます。

OpenShift（およびKubernetes）では、デプロイ可能な最小単位は *Pod* です。
*Pod* は、一緒にデプロイされ、同じホスト上にあることが保証される1つ以上の https://opencontainers.org/[OCIコンテナ, window="_blank"] のグループです。
公式のOpenShiftドキュメントから：

[quote]
__
各 *Pod* には独自のIPアドレスがあり、したがってポートスペース全体を所有し、
Pod内のコンテナはストレージを共有できます。 *Pod* は1つ以上の
ラベルで「タグ付け」することができ、それらは *Pod* のグループを選択し、
単一の操作で管理するために使用されます。
__

*Pod* には複数のOCIコンテナを含めることができます。一般的な考え方は、*Pod* が
「メインプロセス」と、そのプロセスと一緒に実行したい補助サービスを含むことです。
*Pod* に含めるコンテナの例としては、Apache HTTPD
サーバー、ログアナライザー、アップロードされたファイルを管理するファイルサービスなどがあります。

[#examining_the_pod]
== 演習: Podの調査

Topology（トポロジー）ビューで `parksmap` エントリをクリックすると、デプロイメントに関する情報が表示されます。
デフォルトで *Resources*（リソース）タブが表示されているかもしれません。もしそうなら、*Details*（詳細）タブをクリックしてください。

[.bordershadow]
image::switchtoresources.png[link="self",window=_blank]

そのパネルには、あなたのアクションによって作成された単一の *Pod* があることがわかります。

[.bordershadow]
image::parksmap-overview.png[link="self",window=_blank]

NOTE: このビューでは、アプリにヘルスチェックを追加することを提案する情報ボックスが表示されます。
これについては後で対応しますので、今のところ、右上のXアイコンをクリックしてこの情報ボックスを閉じることができます。
Webコンソールの *Workloads -> Pods*（ワークロード -> Pod）に移動して、*Project*（プロジェクト）内に作成されたすべての *Pod* のリストを取得することもできます。

[.bordershadow]
image::parksmap-podlist.png[link="self",window=_blank]

この *Pod* には単一のコンテナが含まれており、
それが `parksmap` アプリケーション - シンプルなSpring Boot/Javaアプリケーションです。
コマンドラインから *Pod* を調べることもできます：

[source,role="copypaste"]
----
oc get pods
----

次のような出力が表示されるはずです：

[.console-output]
[source]
----
NAME                        READY   STATUS    RESTARTS   AGE
parksmap-6444cdcd46-hp9st   1/1     Running   0          50s
----

上記の出力は、現在の *Project*（プロジェクト）内のすべての *Pod* をリストしており、
*Pod* 名、状態、再起動回数、稼働時間が含まれます。 *Pod* の名前がわかれば、
`oc get` コマンドを使用して *Pod* に関する詳細情報を取得できます。
次の構文を使用して、出力形式を *YAML* に変更します：

NOTE: 必ず自分の出力から正しい *Pod* 名を使用してください。
[source,role="copypaste"]
----
oc get pod parksmap-1-gxbgq -o yaml
----

（このワークショップのスペースの都合上、切り詰められています）次のような出力が表示されるはずです：

[source,text]
----
apiVersion: v1
kind: Pod
metadata:
  annotations:
    k8s.v1.cni.cncf.io/network-status: |-
      [{
          "name": "",
          "interface": "eth0",
          "ips": [
              "10.131.0.93"
          ],
     "default": true,
          "dns": {}
      }]
    k8s.v1.cni.cncf.io/networks-status: |-
      [{
          "name": "",
          "interface": "eth0",
          "ips": [
              "10.131.0.93"
          ],
 "default": true,
          "dns": {}
      }]
    openshift.io/generated-by: OpenShiftWebConsole
    openshift.io/scc: restricted
  creationTimestamp: "2021-01-05T17:00:32Z"
  generateName: parksmap-65c4f8b676-
  labels:
    app: parksmap
    component: parksmap
    deployment: parksmap
    pod-template-hash: 65c4f8b676
    role: frontend
...............
----

Webインターフェースは、*Pod* の詳細ページで
同じ情報の多くを表示します。 *Pod* の名前をクリックすると、
詳細ページが表示されます。 *Topology*（トポロジー）ページで `parksmap` Deployment（デプロイメント）をクリックし、*Resources*（リソース）を選択し、*Pod* 名をクリックしてもそこに到達できます。

[.bordershadow]
image::parksmap-dc-resources.png[link="self",window=_blank]

ここから、設定、メトリクス、環境変数、ログ、イベントを確認したり、実行中のPodでターミナルシェルを取得したりできます。

[.bordershadow]
image::parksmap-pod.png[link="self",window=_blank]

[.bordershadow]
image::parksmap-pod-events.png[link="self",window=_blank]

`parksmap` イメージの実行が完了するまでに少し時間がかかる場合があります。
イメージの実行を要求された各OpenShiftノードは、
ノードがローカルにキャッシュしていない場合、それをプル（ダウンロード）する必要があります。
イメージのダウンロードとデプロイのステータスは、*Pod* の詳細ページ、
または以前に使用した `oc get pods` コマンドでコマンドラインから確認できます。

[#customizing_image_lifecycle_behavior]
== 背景: イメージライフサイクル動作のカスタマイズ

OpenShiftがノードのCRI（コンテナランタイムインターフェース）ランタイム（DockerデーモンまたはCRI-O）にイメージの実行を要求するたびに、ランタイムは実行するイメージの正しいバージョンがあることを確認します。
持っていない場合は、指定されたレジストリからプルします。
この動作をカスタマイズする方法は多数あります。それらは link:{ocp4_starter_openshift_docs}/html/images/managing-images[OpenShiftドキュメント,window='_blank'] に概説されています。

[#services]
== 背景: Service（サービス）

*Service*（サービス）は、OpenShift内で
*Pod*（ポッド）へのトラフィックをルーティングするための便利な抽象化レイヤーを提供します。
それらはまた、それらの *Pod* に送信されるトラフィックのロードバランサーとしても機能します。
例えば、増加したトラフィックを処理するためにより多くの `parksmap` インスタンスが必要な場合、
より多くの *Pod* をスピンアップ（起動）できます。 OpenShiftは
それらのPodを *Service* のエンドポイントとして自動的にマッピングし、受信リクエストは
`parksmap` がリクエストをよりうまく処理していること以外、
何も違いに気付かないでしょう。
イメージを実行するようにOpenShiftに要求したとき、自動的に *Service* が
作成されました。 サービスは内部的な構成要素であることを覚えておいてください。
「外部の世界」、つまりOpenShift環境の
外部にあるものからは利用できません。
それでも問題ありません。これに対処するために *Route*（ルート）を使用する方法を後で学びます。
*Service* は *Selector*（セレクター）を使用して *Pod* のセットにマッピングされます。
*Selector* は *Label*（ラベル）を使用して、どのPodがトラフィックを受信すべきかを決定します。
link:{ocp4_starter_openshift_docs}/html/networking_overview[Service,window='_blank']
に関する詳細情報（手動で作成するためのYAML形式を含む）は、
公式のOpenShiftドキュメントにあります。
*Service* が何であるかの基本を理解したところで、
デプロイしたイメージ