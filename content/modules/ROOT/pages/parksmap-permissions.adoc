= パーミッション（権限）
:navtitle: パーミッション（権限）

include::vars.adoc[]

OpenShift環境とのほとんどすべての対話は、
OpenShiftのコントロールプレーンAPIを経由する必要があります。
すべてのAPIとの対話は、認証（AuthN - あなたは誰か？）と認可（AuthZ - あなたは要求していることを実行する許可があるか？）の両方が行われます。
ロギングのセクションで、*Service Account*（サービスアカウント）に関連する
エラーを見ました。 OpenShiftは宣言的なプラットフォームであるため、
一部のアクションは、コマンドを発行するエンドユーザーではなく、プラットフォームによって実行されます。
これらのアクションは、プラットフォームが内部で使用する特別な種類の `user` である *Service Account*（サービスアカウント）を使用して実行されます。
OpenShiftは、すべてのプロジェクトにいくつかの特別なサービスアカウントを自動的に作成します。
**default** サービスアカウントはPodの実行を担当し、OpenShiftは起動される
すべてのPodにこのサービスアカウントを自動的に挿入（inject）します。
そのサービスアカウントの権限を変更することで、
追加機能を有効にすることができます。

Webコンソールで現在の権限を表示するには、{ocp4_starter_console_url}/topology/ns/{ocp4_starter_project}[Topology（トポロジー）ビュー, link="self",window=_blank] に移動し、`parksmap` エントリをクリックし、*Details*（詳細）タブに移動してから、*Namespace*（名前空間）をクリックします。

[.bordershadow]
image::parksmap-permissions-namespace.png[link="self",window=_blank]

*Role Bindings*（ロールバインディング）タブを選択し、*Namespace Role Binding*（名前空間ロールバインディング）でフィルターして、選択したプロジェクトのすべての権限を表示します。

[.bordershadow]
image::parksmap-permissions-membership.png[link="self",window=_blank]

[#grant_serviceaccount_view_permissions]
== 演習: サービスアカウントへの表示（view）権限の付与
parksmapアプリケーションは、OpenShift APIと対話し、*Project*（プロジェクト）内の他の
*Pods*（ポッド）、*Services*（サービス）などのリソースについて知りたいと思っています。
その理由はすぐにわかります！

parksmapアプリケーションは、クラスター上のプロジェクト内で *Service Account*（サービスアカウント）として実行されます：すなわち、`default` の *Service Account* です。
この *Service Account* に必要な `view`（表示）アクセス権を付与して、APIをクエリし、*Project*（プロジェクト）内にどのようなリソースがあるかを確認できるようにすることができます。
これにより、以前ログで見たエラーメッセージの原因に対処できます。
以下の *OpenShift Console*（OpenShiftコンソール）または *`oc` command line*（`oc`コマンドライン）のいずれかのオプションを選択して、`{ocp4_starter_project}` プロジェクトの `default` *Service Account*（サービスアカウント）を更新してください：

====
*オプションA: OpenShift Console:*

.
 *Home*（ホーム）-> *Projects*（プロジェクト）-> *{ocp4_starter_project}* に移動し、*Role Bindings*（ロールバインディング）をクリックしてから *Create Binding*（バインディングの作成）ボタンをクリックします。
+
image::parksmap-permissions-membership-serviceaccount-list.png[link="self",window=_blank]
+
.
 以下のフィールドを設定します：
  * Role Binding Name（ロールバインディング名）: *view*
  * Namespace（名前空間）: *{ocp4_starter_project}*
  * Role Name（ロール名）: *view*, Subject（サブジェクト）: *Service Account*（サービスアカウント）
  * Subject Namespace（サブジェクトの名前空間）: *{ocp4_starter_project}*
  * Subject Name（サブジェクト名）: *default*。
+
image::parksmap-permissions-membership-serviceaccount-edit.png[link="self",window=_blank]
+
. 権限の編集が完了したら、*Create*（作成）ボタンをクリックします。
`{ocp4_starter_project}` プロジェクトの *RoleBindings*（ロールバインディング）リストに、新しい `view` アイテムが表示されるはずです。
+
image::parksmap-permissions-membership-serviceaccount-done.png[link="self",window=_blank]

*オプションB: `oc` command line:*

まず、正しいプロジェクトコンテキストにいることを確認します：

[source,role="copypaste",subs="attributes"]
----
oc project {ocp4_starter_project}
----

次に `oc policy add-role-to-user` コマンドを使用して、事前定義された `view` ロールをサービスアカウントに付与します：

[source,role="copypaste"]
----
oc policy add-role-to-user view -z default
----

.`-z` フラグは何をしますか？
 ****
`oc policy` の `-h` 出力から：

[source]
----
-z, --serviceaccount=[]: userとして使用する現在のnamespaceのサービスアカウント
----

`-z` 構文は、文字列全体（この場合は
`system:serviceaccount:{ocp4_starter_project}:default`）を入力する手間を省く特別なものです。
便利なショートカットです。
****

NOTE: `-z` フラグは、*現在*のプロジェクトのサービスアカウントに対してのみ機能します。
別のプロジェクトのサービスアカウントを参照する場合は、`-n <project>` スイッチを使用してください。
====

[#redeploy_application]
== 演習: アプリケーションの再デプロイ

`oc rollout` コマンドを使用して、`parksmap` アプリケーションを再起動します。これにより、新しいPodが作成されます。
[source,role="copypaste"]
----
oc rollout restart deployment/parksmap
----

すぐに新しいデプロイメントが開始されます。Topology（トポロジー）ビューに戻り、`parksmap` エントリを再度クリックして、それが行われるのを見てください。
デプロイメントは迅速に行われますが、*ReplicaSet*（レプリカセット）番号に変更が反映されているのがわかります。
`oc get pods` コマンドを使用して、新しいPodのAGE（経過時間）がわずか数秒であることを確認することもできます。

[.bordershadow]
image::parksmap-permissions-redeployed.png[link="self",window=_blank]

アプリケーションログを確認すると、エラーが表示されなくなるはずです。