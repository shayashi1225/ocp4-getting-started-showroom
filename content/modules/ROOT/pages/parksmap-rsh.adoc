= コンテナへの接続
:navtitle: コンテナへの接続

include::vars.adoc[]

コンテナはイミュータブル（不変）インフラストラクチャとして扱われるため、
SSHやコンテナ内でのカスタムコマンドの実行によってコンテナのコンテンツを変更することは
一般的に推奨されません。 とはいえ、アプリケーションのデバッグなど、
一部のユースケースでは、コンテナにアクセスして
アプリケーションを調査することが有益な場合があります。

[#remote_shell_to_container_using_cli]
== 演習: CLIを使用したコンテナへのリモートシェルセッション

OpenShiftは、各コンテナ内でSSHサービスを実行する必要なく、
コンテナへのリモートシェルセッションを確立することを可能にします。
コンテナ内でインタラクティブセッションを確立するためには、
`oc rsh` コマンドを使用できます。 まず、
利用可能なPodのリストを取得します：

[source,role="copypaste"]
----
oc get pods
----

以下のような出力が表示されるはずです：

[.console-output]
[source]
----
NAME                        READY   STATUS    RESTARTS   AGE
parksmap-65c4f8b676-fxcrq   1/1     Running   0          52m
----

Pod名を使用して、Podへのリモートシェルセッションを確立できます：

[source,role="copypaste"]
----
oc rsh parksmap-65c4f8b676-fxcrq
----

以下の出力が表示されます：

[.console-output]
[source]
----
sh-4.2$
----

[NOTE]
====
`oc rsh` で使用されるデフォルトのシェルは
`/bin/sh` です。 デプロイされたコンテナに
*sh* がインストールされておらず、別のシェル（例：*bash*）を使用している場合、
発行するコマンドのPod名の後にシェルコマンドを指定できます。
====

次のコマンドを実行して、ルートディレクトリのファイルを一覧表示します：

[source,role="copypaste"]
----
ls /
----

[.console-output]
[source]
----
anaconda-post.log  bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  parksmap.jar  proc  root  run  sbin  srv  sys  tmp  usr  var
----

以前に言及したデフォルトのService Account（サービスアカウント）を覚えていますか？
次のコマンドを使用して、コンテナに挿入（inject）されたそのService Accountに関連付けられたトークンを表示できます：

[source,role="copypaste"]
----
cat /var/run/secrets/kubernetes.io/serviceaccount/token
----

[#remote_shell_session_to_container_using_webconsole]
== 演習: Webコンソールを使用したコンテナへのリモートシェルセッション

OpenShift Webコンソールは、CLIを使用せずにコンテナ上のターミナルセッションにアクセスする便利な方法も提供します。
Webコンソール経由でPodのターミナルにアクセスするには、Topology（トポロジー）ビューに移動し、`parksmap` エントリをクリックし、*Pod* をクリックします。

[.bordershadow]
image::parksmap-rsh-dev-console-pod.png[link="self",window=_blank]

選択したPodの情報を表示したら、*Terminal*（ターミナル）タブをクリックしてシェルセッションを開きます。

[.bordershadow]
image::parksmap-rsh-applications-pods-terminal.png[link="self",window=_blank]

CLIを使用したときと同じコマンドを実行して、Webコンソールベースのターミナルがどのように動作するかを確認してください。
先に進む前に、Podへの接続を閉じます：

[source,role="copypaste"]
----
exit
----

[#execute_command_in_container]
== 演習: コンテナ内でのコマンド実行

リモートシェルに加えて、`oc exec` コマンドを使用して、
すでに実行中のコンテナでリモートでコマンドを実行することも可能です。
これにはシェルがインストールされている必要はありませんが、
目的のコマンドが存在し、実行可能パスにあることだけが必要です。
`parksmap` アプリケーションのJARファイルだけを表示するには、以下を実行します：

[source,role="copypaste"]
----
oc exec parksmap-65c4f8b676-fxcrq -- ls -l /parksmap.jar
----

次のような出力が表示されるはずです：

[.console-output]
[source]
----
-rw-r--r--.
 1 root root 39138901 Apr  1 16:54 /parksmap.jar
----

[NOTE]
====
`oc exec` コマンドの `--` 構文は、execのオプションが
どこで終わり、実行する実際のコマンドがどこで始まるかを示します。
詳細については `oc exec --help` を見てください。
====

`oc rsh` コマンドで実行するシェルコマンドを直接指定することもできます：

[source,role="copypaste"]
----
oc rsh parksmap-65c4f8b676-fxcrq whoami
----

次のように表示されます：

[.console-output]
[source]
----
1000580000
----

[NOTE]
====
セキュリティ上の理由から、OpenShiftはデフォルトではDockerfileで指定されたユーザーとしてコンテナを実行しないことを理解することが重要です。 実際、
OpenShiftがコンテナを起動すると、そのユーザーはランダム化されます。
OpenShiftユーザーにroot（または任意の特定のユーザー）として実行されることを期待するコンテナイメージのデプロイを
許可する必要がある場合は、小さな設定変更が必要です。
OpenShiftの
link:{ocp4_starter_openshift_docs}/html/images/creating-images[コンテナイメージガイドライン,window='_blank'] 
について詳しく学ぶことができます。
====